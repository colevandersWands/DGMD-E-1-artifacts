# Notional Machine Analysis Template

**Purpose**: Use this template during Phase 1 literature review to systematically analyze each notional machine identified in research.

---

## Basic Information

**Model Name:** [As listed in research source]
**Source:** [Paper/Website where documented]
**Target Concept:** [What programming concept it teaches]
**Target Audience:** [Novice/Intermediate/Advanced learners]

---

## Model Characteristics

### Physical Metaphor
[What real-world analogy or metaphor is used? e.g., "post office" for message passing]

### Abstraction Level
[How detailed vs simplified is the model? What details are intentionally hidden?]

### Scope
[What aspects of execution does it cover? Variables? Control flow? Memory? Concurrency?]

---

## Explicit Representations

### What It Makes Visible
- Memory/Storage: [How variables, objects, data structures are shown]
- Control Flow: [How execution order, branching, loops are visualized]
- State Changes: [How mutations and updates are represented]
- Timing: [How temporal aspects are shown]

### Interaction Mechanisms
[How do students engage with the model? Static diagrams? Interactive stepping? Animation?]

### Progressive Disclosure
[What information is revealed at what points? Is complexity introduced gradually?]

---

## Implicit Gaps

### What Remains Abstract
[What aspects still require mental modeling even with this notional machine?]

### Potential Misconceptions
[What might students misunderstand based on the metaphor or simplifications?]

### Missing Transitions
[Are there gaps between this model and other models? What concepts fall between?]

---

## Data Requirements for Implementation

### Execution State Needed
- Variables: [Declaration, assignment, reads, scope]
- Call Stack: [Function calls, returns, parameters]
- Heap/Memory: [Object creation, references, garbage collection]
- Control Flow: [Current statement, branches taken, loop iterations]

### Timing Information
- Synchronous: [Statement-by-statement execution order]
- Asynchronous: [Event queue, callback timing, promise resolution]
- Performance: [Execution time, memory usage]

### Interaction Tracking Needed
[What user engagement data would validate understanding? Clicks? Predictions? Manipulations?]

### Assessment Integration
[How can understanding be measured? What patterns indicate comprehension vs confusion?]

---

## JavaScript Relevance

### Direct Applicability
[Can this notional machine be used for JavaScript as-is? What aspects transfer directly?]

### Adaptation Needed
[What modifications are required to make this work for JavaScript? Event loop? Prototypes?]

### Missing JS Concepts
[What JavaScript-specific concepts aren't covered by this model?]
- Asynchronous execution and event loop
- Closure and lexical scope
- Prototypal inheritance
- This binding and context
- Hoisting and TDZ

---

## Trace Data Enablement Analysis

### What Educational Tools Need to Do
[Based on this notional machine, what analysis/visualization would tools implement?]

### How Trace Data Enables It
[What specific trace events, state snapshots, or execution data would make this possible?]

### Configuration Requirements
[What granularity controls or filtering would be needed?]

---

## Research Citations

**Original Source:** [Full citation]
**Key Studies Using This Model:** [List papers that applied/validated this model]
**Empirical Validation:** [Has effectiveness been measured? Results?]

---

## Notes and Questions

[Any additional observations, questions for further research, or connections to other models]
